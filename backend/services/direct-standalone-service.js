const { execSync } = require('child_process');
const path = require('path');
const fs = require('fs');

/**
 * Service to execute the working standalone scripts directly
 * Uses the exact same scripts that generate perfect TikZ diagrams and visual elements
 */
class DirectStandaloneService {
  
  /**
   * Run the complete pipeline using direct standalone scripts
   */
  static async runCompletePipeline(pdfPath, options = {}) {
    console.log('üöÄ RUNNING DIRECT STANDALONE SCRIPTS PIPELINE');
    console.log(`üìÑ Input PDF: ${pdfPath}`);
    
    try {
      // Get the project root directory (parent of backend)
      const projectRoot = path.join(__dirname, '../../');
      console.log(`üìÇ Project root: ${projectRoot}`);
      
      // Step 1: PDF Extraction
      console.log('\n=== STEP 1: DIRECT PDF EXTRACTION ===');
      const step1Command = `node step1-pdf-extraction.js "${pdfPath}"`;
      console.log(`üîß Running: ${step1Command}`);
      
      const step1Output = execSync(step1Command, { 
        encoding: 'utf8',
        cwd: projectRoot,
        stdio: 'pipe'
      });
      
      console.log('‚úÖ Step 1 completed');
      console.log(`üìÑ Step 1 output length: ${step1Output.length} chars`);
      
      // Step 2: Simple Gemini Conversion
      console.log('\n=== STEP 2: DIRECT GEMINI CONVERSION ===');
      const step2Command = `node simple-gemini-conversion.js`;
      console.log(`üîß Running: ${step2Command}`);
      
      const step2Output = execSync(step2Command, {
        encoding: 'utf8', 
        cwd: projectRoot,
        stdio: 'pipe'
      });
      
      console.log('‚úÖ Step 2 completed');
      console.log(`üìÑ Step 2 output length: ${step2Output.length} chars`);
      
      // Step 2.5: Smart Context-Aware Generation
      console.log('\n=== STEP 2.5: DIRECT SMART GENERATION ===');
      const step25Command = `node step2.5-SMART-context-aware.js`;
      console.log(`üîß Running: ${step25Command}`);
      
      const step25Output = execSync(step25Command, {
        encoding: 'utf8',
        cwd: projectRoot,
        stdio: 'pipe'
      });
      
      console.log('‚úÖ Step 2.5 completed');
      console.log(`üìÑ Step 2.5 output length: ${step25Output.length} chars`);
      
      // Find the generated files in step2.5-output directory
      const step25OutputDir = path.join(projectRoot, 'step2.5-output');
      console.log(`üìÇ Looking for output in: ${step25OutputDir}`);
      
      if (!fs.existsSync(step25OutputDir)) {
        throw new Error(`Step 2.5 output directory not found: ${step25OutputDir}`);
      }
      
      // Get the latest generated PDF file
      const step25Files = fs.readdirSync(step25OutputDir)
        .filter(file => file.startsWith('smart-context-exam-') && file.endsWith('.pdf'))
        .map(file => ({
          name: file,
          path: path.join(step25OutputDir, file),
          mtime: fs.statSync(path.join(step25OutputDir, file)).mtime
        }))
        .sort((a, b) => b.mtime - a.mtime); // Sort by modification time, newest first
        
      if (step25Files.length === 0) {
        throw new Error('No PDF generated by step2.5 script');
      }
      
      const latestPdf = step25Files[0];
      console.log(`üìÑ Latest generated PDF: ${latestPdf.name}`);
      
      // Copy the PDF to backend uploads directory for web access
      const uploadsDir = path.join(__dirname, '../uploads');
      if (!fs.existsSync(uploadsDir)) {
        fs.mkdirSync(uploadsDir, { recursive: true });
      }
      
      const webPdfFilename = `direct-generated-${Date.now()}.pdf`;
      const webPdfPath = path.join(uploadsDir, webPdfFilename);
      fs.copyFileSync(latestPdf.path, webPdfPath);
      
      console.log(`üìÑ PDF copied to web directory: ${webPdfPath}`);
      
      // Get the corresponding LaTeX file
      const latexFilename = latestPdf.name.replace('.pdf', '.tex');
      const latexPath = path.join(step25OutputDir, latexFilename);
      
      let latexContent = '';
      if (fs.existsSync(latexPath)) {
        latexContent = fs.readFileSync(latexPath, 'utf8');
        console.log(`üìÑ LaTeX content loaded: ${latexContent.length} chars`);
      } else {
        console.log('‚ö†Ô∏è LaTeX file not found, using placeholder');
        latexContent = 'LaTeX content not available';
      }
      
      // Get PDF file size
      const pdfSize = fs.statSync(webPdfPath).size;
      console.log(`üìÑ Generated PDF size: ${pdfSize} bytes`);
      
      const result = {
        success: true,
        pdfPath: webPdfPath,
        webPdfFilename: webPdfFilename,
        latexContent: latexContent,
        pdfSize: pdfSize,
        step1Output: step1Output,
        step2Output: step2Output,
        step25Output: step25Output,
        originalPdfPath: pdfPath,
        generatedAt: new Date().toISOString()
      };
      
      console.log('\n‚úÖ DIRECT STANDALONE SCRIPTS PIPELINE COMPLETED SUCCESSFULLY');
      console.log(`üìä Result keys: ${Object.keys(result).join(', ')}`);
      console.log(`üìÑ Final PDF: ${result.webPdfFilename} (${result.pdfSize} bytes)`);
      
      return result;
      
    } catch (error) {
      console.error('‚ùå Direct standalone scripts pipeline failed:', error);
      console.error('Error details:', error.message);
      if (error.stdout) console.error('Stdout:', error.stdout.toString());
      if (error.stderr) console.error('Stderr:', error.stderr.toString());
      
      throw new Error(`Direct scripts pipeline failed: ${error.message}`);
    }
  }
  
  /**
   * Extract questions from LaTeX content for API response
   */
  static extractQuestionsFromLatex(latexContent) {
    console.log('üîç Extracting questions from LaTeX content...');
    
    try {
      // Remove LaTeX preamble and document structure to get raw content
      const documentStartMatch = latexContent.match(/\\begin\{document\}([\s\S]*?)\\end\{document\}/);
      let rawContent = documentStartMatch ? documentStartMatch[1] : latexContent;
      
      console.log(`üìÑ Raw document content length: ${rawContent.length}`);
      
      // Extract sections (Problems/Questions)
      const sectionMatches = rawContent.match(/\\section\*?\{[^}]*\}([\s\S]*?)(?=\\section\*?\{|$)/g) || [];
      
      const questions = [];
      
      sectionMatches.forEach((section, index) => {
        // Extract section title
        const titleMatch = section.match(/\\section\*?\{([^}]*)\}/);
        const title = titleMatch ? titleMatch[1] : `Question ${index + 1}`;
        
        // Extract content after section title
        let content = section.replace(/\\section\*?\{[^}]*\}/, '').trim();
        
        // Clean up LaTeX formatting for display
        content = content
          .replace(/\\textbf\{([^}]*)\}/g, '**$1**')  // Bold to markdown
          .replace(/\\textit\{([^}]*)\}/g, '*$1*')    // Italic to markdown
          .replace(/\\begin\{itemize\}/g, '')         // Remove itemize
          .replace(/\\end\{itemize\}/g, '')
          .replace(/\\item\s*/g, '‚Ä¢ ')                // Items to bullets
          .replace(/\\begin\{enumerate\}/g, '')       // Remove enumerate  
          .replace(/\\end\{enumerate\}/g, '')
          .replace(/\\\\/g, '\n')                     // Line breaks
          .replace(/\n\s*\n/g, '\n\n')               // Clean up spacing
          .trim();
        
        if (content.length > 20) { // Only include substantial content
          questions.push({
            title: title,
            content: content,
            rawLatex: section
          });
        }
      });
      
      // If no sections found, try to extract enumerate blocks
      if (questions.length === 0) {
        const enumerateMatches = rawContent.match(/\\begin\{enumerate\}([\s\S]*?)\\end\{enumerate\}/g) || [];
        
        enumerateMatches.forEach((block, index) => {
          let content = block
            .replace(/\\begin\{enumerate\}/g, '')
            .replace(/\\end\{enumerate\}/g, '')
            .replace(/\\item\s*/g, `${index + 1}. `)
            .replace(/\\\\/g, '\n')
            .trim();
            
          if (content.length > 20) {
            questions.push({
              title: `Question Block ${index + 1}`,
              content: content,
              rawLatex: block
            });
          }
        });
      }
      
      // If still no questions, create a simple split
      if (questions.length === 0) {
        const lines = rawContent.split('\n').filter(line => line.trim().length > 0);
        if (lines.length > 0) {
          questions.push({
            title: 'Generated Questions',
            content: lines.slice(0, 10).join('\n'), // First 10 meaningful lines
            rawLatex: rawContent.substring(0, 500)
          });
        }
      }
      
      console.log(`‚úÖ Found ${questions.length} structured questions`);
      
      // Create a simple text version for the old API format
      const questionTexts = questions.map((q, i) => `${i + 1}. ${q.content.substring(0, 200)}${q.content.length > 200 ? '...' : ''}`);
      const questionsText = questionTexts.join('\n\n');
      
      console.log(`‚úÖ Extracted questions from LaTeX: ${questionsText.substring(0, 200)}...`);
      
      return questionsText;
      
    } catch (error) {
      console.error('‚ùå Question extraction failed:', error.message);
      return 'Questions generated successfully. Please view the PDF for complete content.';
    }
  }
  
  /**
   * Clean up temporary files
   */
  static async cleanup(tempPaths = []) {
    for (const tempPath of tempPaths) {
      try {
        if (fs.existsSync(tempPath)) {
          fs.unlinkSync(tempPath);
          console.log(`üßπ Cleaned up: ${tempPath}`);
        }
      } catch (error) {
        console.log(`‚ö†Ô∏è Could not clean up ${tempPath}: ${error.message}`);
      }
    }
  }
}

module.exports = DirectStandaloneService; 