const admin = require('firebase-admin');
const config = require('../config/config');
const Classroom = require('../models/classroom.model');

// Firestore references
const db = admin.firestore();
const chatSessionsRef = db.collection('chatSessions');
const chatMessagesRef = db.collection('chatMessages');
const quizzesRef = db.collection('quizzes');
const quizResultsRef = db.collection('quizResults');

/**
 * Generate a personalized study plan with classroom context
 * @param {Object} params - Parameters for study plan generation
 * @param {string} params.userId - User ID
 * @param {string} params.courseId - Course ID
 * @param {string} params.classroomId - Classroom ID (optional)
 * @param {string[]} params.topics - Topics to cover
 * @param {number} params.timeAvailable - Time available in minutes
 * @param {string} params.difficulty - Difficulty level (beginner, intermediate, advanced)
 * @returns {Promise<Object>} - Generated study plan
 */
async function generateStudyPlan(params) {
  const { userId, courseId, classroomId, topics, timeAvailable, difficulty } = params;
  
  // Get classroom context if provided
  let classroomContext = null;
  if (classroomId) {
    const classroom = await Classroom.getById(classroomId);
    if (classroom && (classroom.teacherId === userId || classroom.enrolledStudents.includes(userId))) {
      classroomContext = {
        name: classroom.name,
        subject: classroom.subject,
        materials: classroom.materials,
        aiSettings: classroom.aiSettings
      };
    }
  }
  
  // Mock response for development
  const studyPlan = {
    userId,
    courseId,
    classroomId,
    topics,
    timeAvailable,
    difficulty,
    classroomContext,
    plan: `This is a mock study plan for ${courseId} covering ${topics.join(', ')}. 
    It's designed for a ${difficulty} level student with ${timeAvailable} minutes available.
    ${classroomContext ? `This plan incorporates materials from "${classroomContext.name}" classroom.` : ''}
    In a production environment, this would be generated by an AI model with full course context.`,
    createdAt: new Date(),
  };
  
  return studyPlan;
}

/**
 * Answer a student's question with classroom and integration context
 * @param {Object} params - Parameters for question answering
 * @param {string} params.userId - User ID
 * @param {string} params.question - Student's question
 * @param {string} params.courseId - Course ID
 * @param {string} params.classroomId - Classroom ID (optional)
 * @param {string} params.context - Additional context
 * @returns {Promise<Object>} - Answer to the question
 */
async function answerQuestion(params) {
  const { userId, question, courseId, classroomId, context } = params;
  
  // Get classroom context and integration data
  let enhancedContext = context || '';
  let availableMaterials = [];
  
  if (classroomId) {
    const classroom = await Classroom.getById(classroomId);
    if (classroom && (classroom.teacherId === userId || classroom.enrolledStudents.includes(userId))) {
      // Add classroom materials to context
      availableMaterials = classroom.materials || [];
      
      // Get integration data for this student
      const studentIntegrations = classroom.integrations[userId] || {};
      const integrationContext = [];
      
      Object.entries(studentIntegrations).forEach(([platform, data]) => {
        if (data.isActive) {
          integrationContext.push(`${platform}: ${data.courses?.length || 0} courses connected`);
        }
      });
      
      if (integrationContext.length > 0) {
        enhancedContext += `\nConnected platforms: ${integrationContext.join(', ')}`;
      }
      
      // Track AI interaction for analytics
      await Classroom.trackAIInteraction(classroomId, userId, 'question_answer');
    }
  }
  
  // Mock response for development
  const answer = {
    userId,
    courseId,
    classroomId,
    question,
    answer: `This is a mock answer to your question: "${question}" about ${courseId}.
    ${availableMaterials.length > 0 ? `I have access to ${availableMaterials.length} course materials to help answer this.` : ''}
    ${enhancedContext ? `Additional context: ${enhancedContext}` : ''}
    In a production environment, this would be generated by an AI model with full course integration context.`,
    materials: availableMaterials,
    createdAt: new Date(),
  };
  
  return answer;
}

/**
 * Explain a concept in detail
 * @param {Object} params - Parameters for concept explanation
 * @param {string} params.userId - User ID
 * @param {string} params.concept - Concept to explain
 * @param {string} params.courseId - Course ID
 * @param {string} params.level - Explanation level (basic, intermediate, advanced)
 * @returns {Promise<Object>} - Detailed explanation
 */
async function explainConcept(params) {
  const { userId, concept, courseId, level } = params;
  
  // Mock response for development
  const explanation = {
    userId,
    courseId,
    concept,
    level,
    explanation: `This is a mock explanation of "${concept}" in ${courseId} at a ${level} level.
    In a production environment, this would be generated by an AI model.`,
    createdAt: new Date(),
  };
  
  return explanation;
}

/**
 * Start a new chat session with classroom context
 * @param {Object} params - Parameters for chat session
 * @param {string} params.userId - User ID
 * @param {string} params.courseId - Course ID
 * @param {string} params.classroomId - Classroom ID (optional)
 * @param {string} params.topic - Chat topic
 * @param {string} params.context - Additional context
 * @returns {Promise<Object>} - Created chat session
 */
async function startChat(params) {
  const { userId, courseId, classroomId, topic, context } = params;
  
  // Get classroom context
  let classroomData = null;
  if (classroomId) {
    const classroom = await Classroom.getById(classroomId);
    if (classroom && (classroom.teacherId === userId || classroom.enrolledStudents.includes(userId))) {
      classroomData = {
        id: classroom.id,
        name: classroom.name,
        subject: classroom.subject,
        aiSettings: classroom.aiSettings,
        materials: classroom.materials
      };
      
      // Track AI interaction
      await Classroom.trackAIInteraction(classroomId, userId, 'chat_session_start');
    }
  }
  
  // Create a new chat session
  const chatSession = {
    userId,
    courseId,
    classroomId,
    topic,
    context: context || '',
    classroomData,
    createdAt: new Date(),
    updatedAt: new Date(),
  };
  
  // Save to Firestore
  const docRef = await chatSessionsRef.add(chatSession);
  
  return {
    id: docRef.id,
    ...chatSession,
  };
}

/**
 * Send a message in a chat session with enhanced AI responses
 * @param {Object} params - Parameters for message
 * @param {string} params.userId - User ID
 * @param {string} params.sessionId - Chat session ID
 * @param {string} params.content - Message content
 * @param {string} params.type - Message type (question, explanation, practice)
 * @returns {Promise<Object>} - Created message
 */
async function sendMessage(params) {
  const { userId, sessionId, content, type } = params;
  
  // Get the chat session
  const sessionDoc = await chatSessionsRef.doc(sessionId).get();
  if (!sessionDoc.exists) {
    throw new Error('Chat session not found');
  }
  
  const session = sessionDoc.data();
  if (session.userId !== userId) {
    throw new Error('Unauthorized access to chat session');
  }
  
  // Track AI interaction if in classroom context
  if (session.classroomId) {
    await Classroom.trackAIInteraction(session.classroomId, userId, 'chat_message');
  }
  
  // Enhanced mock response based on classroom context
  let response = '';
  const hasClassroomContext = session.classroomData && session.classroomData.materials?.length > 0;
  
  if (type === 'question') {
    response = `This is a mock answer to your question: "${content}"`;
    if (hasClassroomContext) {
      response += `\n\nBased on materials from "${session.classroomData.name}", here are some relevant resources...`;
    }
  } else if (type === 'explanation') {
    response = `This is a mock explanation of: "${content}"`;
    if (hasClassroomContext) {
      response += `\n\nThis explanation is tailored to the "${session.classroomData.subject}" curriculum.`;
    }
  } else if (type === 'practice') {
    response = `This is mock practice for: "${content}"`;
    if (hasClassroomContext) {
      response += `\n\nHere are some practice problems similar to those in your "${session.classroomData.name}" class...`;
    }
  } else {
    response = `This is a mock response to: "${content}"`;
  }
  
  // Create the message
  const message = {
    userId,
    sessionId,
    content,
    type: type || 'question',
    response,
    classroomContext: session.classroomData,
    createdAt: new Date(),
  };
  
  // Save to Firestore
  const docRef = await chatMessagesRef.add(message);
  
  // Update the session's updatedAt timestamp
  await chatSessionsRef.doc(sessionId).update({
    updatedAt: new Date(),
  });
  
  return {
    id: docRef.id,
    ...message,
  };
}

/**
 * Get chat history
 * @param {Object} params - Parameters for chat history
 * @param {string} params.userId - User ID
 * @param {string} params.sessionId - Chat session ID
 * @returns {Promise<Array>} - Chat messages
 */
async function getChatHistory(params) {
  const { userId, sessionId } = params;
  
  // Get the chat session
  const sessionDoc = await chatSessionsRef.doc(sessionId).get();
  if (!sessionDoc.exists) {
    throw new Error('Chat session not found');
  }
  
  const session = sessionDoc.data();
  if (session.userId !== userId) {
    throw new Error('Unauthorized access to chat session');
  }
  
  // Get all messages for the session
  const messagesSnapshot = await chatMessagesRef
    .where('sessionId', '==', sessionId)
    .orderBy('createdAt', 'asc')
    .get();
  
  const messages = [];
  messagesSnapshot.forEach(doc => {
    messages.push({
      id: doc.id,
      ...doc.data(),
    });
  });
  
  return messages;
}

/**
 * Get all chat sessions for a user
 * @param {string} userId - User ID
 * @returns {Promise<Array>} - Chat sessions
 */
async function getChatSessions(userId) {
  const sessionsSnapshot = await chatSessionsRef
    .where('userId', '==', userId)
    .orderBy('updatedAt', 'desc')
    .get();
  
  const sessions = [];
  sessionsSnapshot.forEach(doc => {
    sessions.push({
      id: doc.id,
      ...doc.data(),
    });
  });
  
  return sessions;
}

/**
 * Delete a chat session
 * @param {Object} params - Parameters for deletion
 * @param {string} params.userId - User ID
 * @param {string} params.sessionId - Chat session ID
 * @returns {Promise<void>}
 */
async function deleteChatSession(params) {
  const { userId, sessionId } = params;
  
  // Get the chat session
  const sessionDoc = await chatSessionsRef.doc(sessionId).get();
  if (!sessionDoc.exists) {
    throw new Error('Chat session not found');
  }
  
  const session = sessionDoc.data();
  if (session.userId !== userId) {
    throw new Error('Unauthorized access to chat session');
  }
  
  // Delete all messages for the session
  const messagesSnapshot = await chatMessagesRef
    .where('sessionId', '==', sessionId)
    .get();
  
  const batch = db.batch();
  messagesSnapshot.forEach(doc => {
    batch.delete(doc.ref);
  });
  
  // Delete the session
  batch.delete(sessionDoc.ref);
  
  // Commit the batch
  await batch.commit();
}

/**
 * Generate context-aware quiz with classroom materials
 * @param {Object} params - Parameters for quiz generation
 * @param {string} params.userId - User ID
 * @param {string} params.courseId - Course ID
 * @param {string} params.classroomId - Classroom ID (optional)
 * @param {string} params.topic - Quiz topic
 * @param {number} params.numQuestions - Number of questions
 * @param {string} params.difficulty - Difficulty level
 * @returns {Promise<Object>} - Generated quiz
 */
async function generateQuiz(params) {
  const { userId, courseId, classroomId, topic, numQuestions, difficulty } = params;
  
  // Get classroom context
  let classroomContext = null;
  if (classroomId) {
    const classroom = await Classroom.getById(classroomId);
    if (classroom && (classroom.teacherId === userId || classroom.enrolledStudents.includes(userId))) {
      classroomContext = classroom;
      await Classroom.trackAIInteraction(classroomId, userId, 'quiz_generation');
    }
  }
  
  // Mock quiz generation
  const questions = [];
  for (let i = 1; i <= numQuestions; i++) {
    questions.push({
      id: i,
      question: `Mock question ${i} about ${topic}${classroomContext ? ` from ${classroomContext.name}` : ''}`,
      options: ['Option A', 'Option B', 'Option C', 'Option D'],
      correctAnswer: 'Option A',
      explanation: `This is a mock explanation for question ${i}`,
      difficulty,
      points: 10,
    });
  }
  
  // Create the quiz
  const quiz = {
    userId,
    courseId,
    classroomId,
    topic,
    difficulty,
    questions,
    classroomContext: classroomContext ? {
      name: classroomContext.name,
      subject: classroomContext.subject
    } : null,
    createdAt: new Date(),
  };
  
  // Save to Firestore
  const docRef = await quizzesRef.add(quiz);
  
  return {
    id: docRef.id,
    ...quiz,
  };
}

/**
 * Submit quiz answers
 * @param {Object} params - Parameters for quiz submission
 * @param {string} params.userId - User ID
 * @param {string} params.quizId - Quiz ID
 * @param {Array} params.answers - User answers
 * @returns {Promise<Object>} - Quiz results
 */
async function submitQuiz(params) {
  const { userId, quizId, answers } = params;
  
  // Get the quiz
  const quizDoc = await quizzesRef.doc(quizId).get();
  if (!quizDoc.exists) {
    throw new Error('Quiz not found');
  }
  
  // Mock feedback for development
  const feedback = `This is mock feedback for your quiz answers. In a production environment, this would be generated by an AI model.`;
  
  // Calculate score (simplified)
  const score = Math.floor(Math.random() * 41) + 60; // Random score between 60-100 for demo
  
  // Create the results
  const results = {
    userId,
    quizId,
    answers,
    feedback,
    score,
    submittedAt: new Date(),
  };
  
  // Save to Firestore
  const docRef = await quizResultsRef.add(results);
  
  return {
    id: docRef.id,
    ...results,
  };
}

/**
 * Get quiz results
 * @param {Object} params - Parameters for quiz results
 * @param {string} params.userId - User ID
 * @param {string} params.quizId - Quiz ID
 * @returns {Promise<Object>} - Quiz results
 */
async function getQuizResults(params) {
  const { userId, quizId } = params;
  
  // Get the quiz results
  const resultsSnapshot = await quizResultsRef
    .where('userId', '==', userId)
    .where('quizId', '==', quizId)
    .orderBy('submittedAt', 'desc')
    .limit(1)
    .get();
  
  if (resultsSnapshot.empty) {
    throw new Error('Quiz results not found');
  }
  
  const doc = resultsSnapshot.docs[0];
  return {
    id: doc.id,
    ...doc.data(),
  };
}

/**
 * Get all quizzes for a user
 * @param {string} userId - User ID
 * @returns {Promise<Array>} - Quizzes
 */
async function getQuizzes(userId) {
  const quizzesSnapshot = await quizzesRef
    .where('userId', '==', userId)
    .orderBy('createdAt', 'desc')
    .get();
  
  const quizzes = [];
  quizzesSnapshot.forEach(doc => {
    quizzes.push({
      id: doc.id,
      ...doc.data(),
    });
  });
  
  return quizzes;
}

/**
 * Generate a study summary
 * @param {Object} params - Parameters for summary generation
 * @param {string} params.userId - User ID
 * @param {string} params.courseId - Course ID
 * @param {string} params.startDate - Start date (ISO string)
 * @param {string} params.endDate - End date (ISO string)
 * @returns {Promise<Object>} - Generated summary
 */
async function generateSummary(params) {
  const { userId, courseId, startDate, endDate } = params;
  
  // Mock response for development
  const summary = {
    userId,
    courseId,
    startDate,
    endDate,
    content: `This is a mock study summary for ${courseId} covering the period from ${startDate} to ${endDate}.
    In a production environment, this would be generated by an AI model.`,
    createdAt: new Date(),
  };
  
  return summary;
}

/**
 * Get available classrooms and courses for AI context
 * @param {string} userId - User ID
 * @returns {Promise<Object>} - Available classrooms and courses
 */
async function getAvailableClassrooms(userId) {
  try {
    const Course = require('../models/course.model');
    
    const teachingClassrooms = await Classroom.getByTeacherId(userId);
    const enrolledClassrooms = await Classroom.getByStudentId(userId);
    
    // Get user's courses
    const userCourses = await Course.getByUserId(userId);
    
    // Transform courses to match classroom format for AI context
    const courseClassrooms = userCourses.map(course => {
      const userIntegrations = course.integrations?.[userId] || {};
      const activeIntegrations = {};
      let userIntegrationCount = 0;
      
      // Filter and count active integrations for this user
      Object.entries(userIntegrations).forEach(([platform, integration]) => {
        if (integration && integration.isActive) {
          activeIntegrations[platform] = integration;
          userIntegrationCount++;
        }
      });
      
      // If this is an imported Gradescope course, treat it as having a Gradescope integration
      if (course.source === 'gradescope' && course.externalId) {
        activeIntegrations.gradescope = {
          isActive: true,
          imported: true,
          externalId: course.externalId,
          courses: [{ id: course.externalId, name: course.name }],
          assignments: course.assignments || [],
          materials: course.materials || []
        };
        userIntegrationCount++;
      }
      
      return {
        id: course.id,
        name: course.name,
        subject: course.code || course.name,
        role: course.userRole,
        type: 'course',
        integrations: activeIntegrations,
        totalIntegrations: userIntegrationCount, // User-specific integration count
        totalAssignments: course.analytics?.totalAssignments || course.assignments?.length || 0,
        semester: course.semester,
        year: course.year,
        instructor: course.instructor
      };
    });
    
    return {
      teaching: teachingClassrooms.map(c => ({
        id: c.id,
        name: c.name,
        subject: c.subject,
        role: 'teacher',
        type: 'classroom'
      })),
      enrolled: enrolledClassrooms.map(c => ({
        id: c.id,
        name: c.name,
        subject: c.subject,
        role: 'student',
        type: 'classroom'
      })),
      courses: courseClassrooms
    };
  } catch (error) {
    console.error('Error getting available classrooms:', error);
    return { teaching: [], enrolled: [], courses: [] };
  }
}

/**
 * Get integrated course materials for AI context
 * @param {string} userId - User ID
 * @param {string} contextId - Classroom or Course ID
 * @param {string} contextType - 'classroom' or 'course'
 * @returns {Promise<Array>} - Course materials from integrations
 */
async function getIntegratedMaterials(userId, contextId, contextType = 'classroom') {
  try {
    const Course = require('../models/course.model');
    
    let materials = [];
    let assignments = [];
    
    if (contextType === 'course') {
      // Handle course context
      const course = await Course.getById(contextId);
      if (!course || !course.members.includes(userId)) {
        return { materials: [], assignments: [] };
      }
      
      // Get materials and assignments from course aggregation
      materials = course.materials || [];
      assignments = course.assignments || [];
      
      // If this is an imported Gradescope course, add its data as materials
      if (course.source === 'gradescope' && course.externalId) {
        // Add course info as material
        materials.push({
          id: course.externalId,
          name: course.name,
          type: 'course',
          platform: 'gradescope',
          contextId,
          contextType: 'course',
          imported: true
        });
      }
      
      // Also get user-specific integration materials
      const userIntegrations = course.integrations[userId] || {};
      Object.entries(userIntegrations).forEach(([platform, integration]) => {
        if (integration && integration.isActive) {
          // Add materials from this integration
          if (integration.materials && Array.isArray(integration.materials)) {
            materials.push(...integration.materials.map(material => ({
              ...material,
              platform,
              contextId,
              contextType: 'course'
            })));
          }
          
          // Add assignments from this integration
          if (integration.assignments && Array.isArray(integration.assignments)) {
            assignments.push(...integration.assignments.map(assignment => ({
              ...assignment,
              platform,
              contextId,
              contextType: 'course'
            })));
          }
        }
      });
      
    } else {
      // Handle classroom context (existing logic)
      const classroom = await Classroom.getById(contextId);
      if (!classroom || (!classroom.enrolledStudents.includes(userId) && classroom.teacherId !== userId)) {
        return { materials: [], assignments: [] };
      }
      
      const studentIntegrations = classroom.integrations[userId] || {};
      
      // Collect materials from all active integrations
      Object.entries(studentIntegrations).forEach(([platform, integration]) => {
        if (integration.isActive && integration.materials) {
          materials.push(...integration.materials.map(material => ({
            ...material,
            platform,
            contextId,
            contextType: 'classroom'
          })));
        }
        
        if (integration.isActive && integration.assignments) {
          assignments.push(...integration.assignments.map(assignment => ({
            ...assignment,
            platform,
            contextId,
            contextType: 'classroom'
          })));
        }
      });
    }
    
    return {
      materials,
      assignments,
      totalMaterials: materials.length,
      totalAssignments: assignments.length
    };
  } catch (error) {
    console.error('Error getting integrated materials:', error);
    return { materials: [], assignments: [] };
  }
}

module.exports = {
  generateStudyPlan,
  answerQuestion,
  explainConcept,
  startChat,
  sendMessage,
  getChatHistory,
  getChatSessions,
  deleteChatSession,
  generateQuiz,
  submitQuiz,
  getQuizResults,
  getQuizzes,
  generateSummary,
  getAvailableClassrooms,
  getIntegratedMaterials
}; 