const admin = require('firebase-admin');
const config = require('../config/config');
const Classroom = require('../models/classroom.model');

// Firestore references
const db = admin.firestore();
const chatSessionsRef = db.collection('chatSessions');
const chatMessagesRef = db.collection('chatMessages');
const quizzesRef = db.collection('quizzes');
const quizResultsRef = db.collection('quizResults');

/**
 * Generate a personalized study plan with classroom context
 * @param {Object} params - Parameters for study plan generation
 * @param {string} params.userId - User ID
 * @param {string} params.courseId - Course ID
 * @param {string} params.classroomId - Classroom ID (optional)
 * @param {string[]} params.topics - Topics to cover
 * @param {number} params.timeAvailable - Time available in minutes
 * @param {string} params.difficulty - Difficulty level (beginner, intermediate, advanced)
 * @returns {Promise<Object>} - Generated study plan
 */
async function generateStudyPlan(params) {
  const { userId, courseId, classroomId, topics, timeAvailable, difficulty } = params;
  
  // Get classroom context if provided
  let classroomContext = null;
  if (classroomId) {
    const classroom = await Classroom.getById(classroomId);
    if (classroom && (classroom.teacherId === userId || classroom.enrolledStudents.includes(userId))) {
      classroomContext = {
        name: classroom.name,
        subject: classroom.subject,
        materials: classroom.materials,
        aiSettings: classroom.aiSettings
      };
    }
  }
  
  // Mock response for development
  const studyPlan = {
    userId,
    courseId,
    classroomId,
    topics,
    timeAvailable,
    difficulty,
    classroomContext,
    plan: `This is a mock study plan for ${courseId} covering ${topics.join(', ')}. 
    It's designed for a ${difficulty} level student with ${timeAvailable} minutes available.
    ${classroomContext ? `This plan incorporates materials from "${classroomContext.name}" classroom.` : ''}
    In a production environment, this would be generated by an AI model with full course context.`,
    createdAt: new Date(),
  };
  
  return studyPlan;
}

/**
 * Answer a student's question with classroom and integration context
 * @param {Object} params - Parameters for question answering
 * @param {string} params.userId - User ID
 * @param {string} params.question - Student's question
 * @param {string} params.courseId - Course ID
 * @param {string} params.classroomId - Classroom ID (optional)
 * @param {string} params.context - Additional context
 * @returns {Promise<Object>} - Answer to the question
 */
async function answerQuestion(params) {
  const { userId, question, courseId, classroomId, context } = params;
  
  // Get enhanced context and integration data
  let enhancedContext = context || '';
  let availableMaterials = [];
  let contextType = 'general';
  let contextId = courseId || classroomId;
  
  // Log in development only
  if (process.env.NODE_ENV === 'development') {
    console.log(`[AI Service] Answering question for user ${userId}, courseId: ${courseId}, classroomId: ${classroomId}`);
  }
  
  // Handle course context (new priority)
  if (courseId) {
    contextType = 'course';
    const courseContext = await getIntegratedMaterials(userId, courseId, 'course');
    availableMaterials = courseContext.materials || [];
    
    if (courseContext.totalMaterials > 0 || courseContext.totalAssignments > 0) {
      enhancedContext += `\nCourse Context: ${courseContext.totalMaterials} materials, ${courseContext.totalAssignments} assignments available.`;
      
      // Add a summary of available materials for context
      const materialSummary = availableMaterials.slice(0, 5).map(material => 
        `- ${material.name}${material.sourcePlatformName ? ` (${material.sourcePlatformName})` : ''}`
      ).join('\n');
      
      if (materialSummary) {
        enhancedContext += `\nAvailable materials:\n${materialSummary}`;
        if (availableMaterials.length > 5) {
          enhancedContext += `\n... and ${availableMaterials.length - 5} more materials`;
        }
      }
    }
  } 
  // Handle classroom context (fallback)
  else if (classroomId) {
    contextType = 'classroom';
    const classroom = await Classroom.getById(classroomId);
    if (classroom && (classroom.teacherId === userId || classroom.enrolledStudents.includes(userId))) {
      // Add classroom materials to context
      availableMaterials = classroom.materials || [];
      
      // Get integration data for this student
      const studentIntegrations = classroom.integrations[userId] || {};
      const integrationContext = [];
      
      Object.entries(studentIntegrations).forEach(([platform, data]) => {
        if (data.isActive) {
          integrationContext.push(`${platform}: ${data.courses?.length || 0} courses connected`);
        }
      });
      
      if (integrationContext.length > 0) {
        enhancedContext += `\nConnected platforms: ${integrationContext.join(', ')}`;
      }
      
      // Track AI interaction for analytics
      await Classroom.trackAIInteraction(classroomId, userId, 'question_answer');
    }
  }
  
  // Log in development only
  if (process.env.NODE_ENV === 'development') {
    console.log(`[AI Service] Context prepared: ${availableMaterials.length} materials, context type: ${contextType}`);
  }
  
  // Use Gemini service for actual AI response
  const GeminiService = require('./gemini.service');
  
  try {
    // Prepare the prompt with context
    let prompt = `You are an AI tutor helping a student. `;
    
    if (availableMaterials.length > 0) {
      prompt += `You have access to course materials and should reference them when relevant. `;
    }
    
    prompt += `Please answer the following question clearly and helpfully:\n\nQuestion: ${question}`;
    
    if (enhancedContext.trim()) {
      prompt += `\n\nContext:\n${enhancedContext}`;
    }
    
    // Get AI response
    const aiResponse = await GeminiService.testGeminiFlash(prompt);
    
    const answer = {
      userId,
      courseId,
      classroomId,
      question,
      answer: aiResponse.text,
      materials: availableMaterials,
      contextType,
      usageMetadata: aiResponse.usageMetadata,
      createdAt: new Date(),
    };
    
    return answer;
  } catch (error) {
    console.error('Error generating AI response:', error);
    
    // Fallback response
    const answer = {
      userId,
      courseId,
      classroomId,
      question,
      answer: `I'm here to help with your question: "${question}". ${availableMaterials.length > 0 ? `I have access to ${availableMaterials.length} course materials to help answer this.` : ''} However, I'm currently experiencing technical difficulties. Please try again in a moment.`,
      materials: availableMaterials,
      contextType,
      error: error.message,
      createdAt: new Date(),
    };
    
    return answer;
  }
}

/**
 * Explain a concept in detail
 * @param {Object} params - Parameters for concept explanation
 * @param {string} params.userId - User ID
 * @param {string} params.concept - Concept to explain
 * @param {string} params.courseId - Course ID
 * @param {string} params.level - Explanation level (basic, intermediate, advanced)
 * @returns {Promise<Object>} - Detailed explanation
 */
async function explainConcept(params) {
  const { userId, concept, courseId, level } = params;
  
  // Mock response for development
  const explanation = {
    userId,
    courseId,
    concept,
    level,
    explanation: `This is a mock explanation of "${concept}" in ${courseId} at a ${level} level.
    In a production environment, this would be generated by an AI model.`,
    createdAt: new Date(),
  };
  
  return explanation;
}

/**
 * Start a new chat session with classroom context
 * @param {Object} params - Parameters for chat session
 * @param {string} params.userId - User ID
 * @param {string} params.courseId - Course ID
 * @param {string} params.classroomId - Classroom ID (optional)
 * @param {string} params.topic - Chat topic
 * @param {string} params.context - Additional context
 * @returns {Promise<Object>} - Created chat session
 */
async function startChat(params) {
  const { userId, courseId, classroomId, topic, context } = params;
  
  // Get classroom context
  let classroomData = null;
  if (classroomId) {
    const classroom = await Classroom.getById(classroomId);
    if (classroom && (classroom.teacherId === userId || classroom.enrolledStudents.includes(userId))) {
      classroomData = {
        id: classroom.id,
        name: classroom.name,
        subject: classroom.subject,
        aiSettings: classroom.aiSettings,
        materials: classroom.materials
      };
      
      // Track AI interaction
      await Classroom.trackAIInteraction(classroomId, userId, 'chat_session_start');
    }
  }
  
  // Create a new chat session
  const chatSession = {
    userId,
    courseId,
    classroomId,
    topic,
    context: context || '',
    classroomData,
    createdAt: new Date(),
    updatedAt: new Date(),
  };
  
  // Save to Firestore
  const docRef = await chatSessionsRef.add(chatSession);
  
  return {
    id: docRef.id,
    ...chatSession,
  };
}

/**
 * Send a message in a chat session with enhanced AI responses
 * @param {Object} params - Parameters for message
 * @param {string} params.userId - User ID
 * @param {string} params.sessionId - Chat session ID
 * @param {string} params.content - Message content
 * @param {string} params.type - Message type (question, explanation, practice)
 * @returns {Promise<Object>} - Created message
 */
async function sendMessage(params) {
  const { userId, sessionId, content, type } = params;
  
  // Get the chat session
  const sessionDoc = await chatSessionsRef.doc(sessionId).get();
  if (!sessionDoc.exists) {
    throw new Error('Chat session not found');
  }
  
  const session = sessionDoc.data();
  if (session.userId !== userId) {
    throw new Error('Unauthorized access to chat session');
  }
  
  // Track AI interaction if in classroom context
  if (session.classroomId) {
    await Classroom.trackAIInteraction(session.classroomId, userId, 'chat_message');
  }
  
  // Enhanced mock response based on classroom context
  let response = '';
  const hasClassroomContext = session.classroomData && session.classroomData.materials?.length > 0;
  
  if (type === 'question') {
    response = `This is a mock answer to your question: "${content}"`;
    if (hasClassroomContext) {
      response += `\n\nBased on materials from "${session.classroomData.name}", here are some relevant resources...`;
    }
  } else if (type === 'explanation') {
    response = `This is a mock explanation of: "${content}"`;
    if (hasClassroomContext) {
      response += `\n\nThis explanation is tailored to the "${session.classroomData.subject}" curriculum.`;
    }
  } else if (type === 'practice') {
    response = `This is mock practice for: "${content}"`;
    if (hasClassroomContext) {
      response += `\n\nHere are some practice problems similar to those in your "${session.classroomData.name}" class...`;
    }
  } else {
    response = `This is a mock response to: "${content}"`;
  }
  
  // Create the message
  const message = {
    userId,
    sessionId,
    content,
    type: type || 'question',
    response,
    classroomContext: session.classroomData,
    createdAt: new Date(),
  };
  
  // Save to Firestore
  const docRef = await chatMessagesRef.add(message);
  
  // Update the session's updatedAt timestamp
  await chatSessionsRef.doc(sessionId).update({
    updatedAt: new Date(),
  });
  
  return {
    id: docRef.id,
    ...message,
  };
}

/**
 * Get chat history
 * @param {Object} params - Parameters for chat history
 * @param {string} params.userId - User ID
 * @param {string} params.sessionId - Chat session ID
 * @returns {Promise<Array>} - Chat messages
 */
async function getChatHistory(params) {
  const { userId, sessionId } = params;
  
  // Get the chat session
  const sessionDoc = await chatSessionsRef.doc(sessionId).get();
  if (!sessionDoc.exists) {
    throw new Error('Chat session not found');
  }
  
  const session = sessionDoc.data();
  if (session.userId !== userId) {
    throw new Error('Unauthorized access to chat session');
  }
  
  // Get all messages for the session
  const messagesSnapshot = await chatMessagesRef
    .where('sessionId', '==', sessionId)
    .orderBy('createdAt', 'asc')
    .get();
  
  const messages = [];
  messagesSnapshot.forEach(doc => {
    messages.push({
      id: doc.id,
      ...doc.data(),
    });
  });
  
  return messages;
}

/**
 * Get all chat sessions for a user
 * @param {string} userId - User ID
 * @returns {Promise<Array>} - Chat sessions
 */
async function getChatSessions(userId) {
  const sessionsSnapshot = await chatSessionsRef
    .where('userId', '==', userId)
    .orderBy('updatedAt', 'desc')
    .get();
  
  const sessions = [];
  sessionsSnapshot.forEach(doc => {
    sessions.push({
      id: doc.id,
      ...doc.data(),
    });
  });
  
  return sessions;
}

/**
 * Delete a chat session
 * @param {Object} params - Parameters for deletion
 * @param {string} params.userId - User ID
 * @param {string} params.sessionId - Chat session ID
 * @returns {Promise<void>}
 */
async function deleteChatSession(params) {
  const { userId, sessionId } = params;
  
  // Get the chat session
  const sessionDoc = await chatSessionsRef.doc(sessionId).get();
  if (!sessionDoc.exists) {
    throw new Error('Chat session not found');
  }
  
  const session = sessionDoc.data();
  if (session.userId !== userId) {
    throw new Error('Unauthorized access to chat session');
  }
  
  // Delete all messages for the session
  const messagesSnapshot = await chatMessagesRef
    .where('sessionId', '==', sessionId)
    .get();
  
  const batch = db.batch();
  messagesSnapshot.forEach(doc => {
    batch.delete(doc.ref);
  });
  
  // Delete the session
  batch.delete(sessionDoc.ref);
  
  // Commit the batch
  await batch.commit();
}

/**
 * Generate context-aware quiz with classroom materials
 * @param {Object} params - Parameters for quiz generation
 * @param {string} params.userId - User ID
 * @param {string} params.courseId - Course ID
 * @param {string} params.classroomId - Classroom ID (optional)
 * @param {string} params.topic - Quiz topic
 * @param {number} params.numQuestions - Number of questions
 * @param {string} params.difficulty - Difficulty level
 * @returns {Promise<Object>} - Generated quiz
 */
async function generateQuiz(params) {
  const { userId, courseId, classroomId, topic, numQuestions, difficulty } = params;
  
  // Get classroom context
  let classroomContext = null;
  if (classroomId) {
    const classroom = await Classroom.getById(classroomId);
    if (classroom && (classroom.teacherId === userId || classroom.enrolledStudents.includes(userId))) {
      classroomContext = classroom;
      await Classroom.trackAIInteraction(classroomId, userId, 'quiz_generation');
    }
  }
  
  // Mock quiz generation
  const questions = [];
  for (let i = 1; i <= numQuestions; i++) {
    questions.push({
      id: i,
      question: `Mock question ${i} about ${topic}${classroomContext ? ` from ${classroomContext.name}` : ''}`,
      options: ['Option A', 'Option B', 'Option C', 'Option D'],
      correctAnswer: 'Option A',
      explanation: `This is a mock explanation for question ${i}`,
      difficulty,
      points: 10,
    });
  }
  
  // Create the quiz
  const quiz = {
    userId,
    courseId,
    classroomId,
    topic,
    difficulty,
    questions,
    classroomContext: classroomContext ? {
      name: classroomContext.name,
      subject: classroomContext.subject
    } : null,
    createdAt: new Date(),
  };
  
  // Save to Firestore
  const docRef = await quizzesRef.add(quiz);
  
  return {
    id: docRef.id,
    ...quiz,
  };
}

/**
 * Submit quiz answers
 * @param {Object} params - Parameters for quiz submission
 * @param {string} params.userId - User ID
 * @param {string} params.quizId - Quiz ID
 * @param {Array} params.answers - User answers
 * @returns {Promise<Object>} - Quiz results
 */
async function submitQuiz(params) {
  const { userId, quizId, answers } = params;
  
  // Get the quiz
  const quizDoc = await quizzesRef.doc(quizId).get();
  if (!quizDoc.exists) {
    throw new Error('Quiz not found');
  }
  
  // Mock feedback for development
  const feedback = `This is mock feedback for your quiz answers. In a production environment, this would be generated by an AI model.`;
  
  // Calculate score (simplified)
  const score = Math.floor(Math.random() * 41) + 60; // Random score between 60-100 for demo
  
  // Create the results
  const results = {
    userId,
    quizId,
    answers,
    feedback,
    score,
    submittedAt: new Date(),
  };
  
  // Save to Firestore
  const docRef = await quizResultsRef.add(results);
  
  return {
    id: docRef.id,
    ...results,
  };
}

/**
 * Get quiz results
 * @param {Object} params - Parameters for quiz results
 * @param {string} params.userId - User ID
 * @param {string} params.quizId - Quiz ID
 * @returns {Promise<Object>} - Quiz results
 */
async function getQuizResults(params) {
  const { userId, quizId } = params;
  
  // Get the quiz results
  const resultsSnapshot = await quizResultsRef
    .where('userId', '==', userId)
    .where('quizId', '==', quizId)
    .orderBy('submittedAt', 'desc')
    .limit(1)
    .get();
  
  if (resultsSnapshot.empty) {
    throw new Error('Quiz results not found');
  }
  
  const doc = resultsSnapshot.docs[0];
  return {
    id: doc.id,
    ...doc.data(),
  };
}

/**
 * Get all quizzes for a user
 * @param {string} userId - User ID
 * @returns {Promise<Array>} - Quizzes
 */
async function getQuizzes(userId) {
  const quizzesSnapshot = await quizzesRef
    .where('userId', '==', userId)
    .orderBy('createdAt', 'desc')
    .get();
  
  const quizzes = [];
  quizzesSnapshot.forEach(doc => {
    quizzes.push({
      id: doc.id,
      ...doc.data(),
    });
  });
  
  return quizzes;
}

/**
 * Generate a study summary
 * @param {Object} params - Parameters for summary generation
 * @param {string} params.userId - User ID
 * @param {string} params.courseId - Course ID
 * @param {string} params.startDate - Start date (ISO string)
 * @param {string} params.endDate - End date (ISO string)
 * @returns {Promise<Object>} - Generated summary
 */
async function generateSummary(params) {
  const { userId, courseId, startDate, endDate } = params;
  
  // Mock response for development
  const summary = {
    userId,
    courseId,
    startDate,
    endDate,
    content: `This is a mock study summary for ${courseId} covering the period from ${startDate} to ${endDate}.
    In a production environment, this would be generated by an AI model.`,
    createdAt: new Date(),
  };
  
  return summary;
}

/**
 * Get available classrooms and courses for AI context
 * @param {string} userId - User ID
 * @returns {Promise<Object>} - Available classrooms and courses
 */
async function getAvailableClassrooms(userId) {
  try {
    const Course = require('../models/course.model');
    
    const teachingClassrooms = await Classroom.getByTeacherId(userId);
    const enrolledClassrooms = await Classroom.getByStudentId(userId);
    
    // Get user's courses
    const userCourses = await Course.getByUserId(userId);
    
    // Transform courses to match classroom format for AI context
    const courseClassrooms = userCourses.map(course => {
      let activeIntegrations = {};
      let userIntegrationCount = 0;
      
      // NEW: Handle user-specific linked integrations (new merge functionality)
      if (course.userLinkedIntegrations && course.userLinkedIntegrations[userId] && course.userLinkedIntegrations[userId].length > 0) {
        console.log(`[AI Service] Course ${course.name} has ${course.userLinkedIntegrations[userId].length} user-specific linked integrations`);
        
        // Transform user-specific linked integrations to match the expected format
        course.userLinkedIntegrations[userId].forEach(linkedIntegration => {
          if (linkedIntegration.isActive) {
            activeIntegrations[linkedIntegration.platform] = {
              isActive: true,
              linked: true,
              integrationId: linkedIntegration.integrationId,
              platformName: linkedIntegration.platformName,
              courseName: linkedIntegration.courseName,
              courseCode: linkedIntegration.courseCode,
              linkedAt: linkedIntegration.linkedAt
            };
            userIntegrationCount++;
          }
        });
      } 
      // Fallback: Handle legacy global linked integrations
      else if (course.linkedIntegrations && course.linkedIntegrations.length > 0) {
        console.log(`[AI Service] Course ${course.name} has ${course.linkedIntegrations.length} legacy linked integrations`);
        
        // Transform linked integrations to match the expected format
        course.linkedIntegrations.forEach(linkedIntegration => {
          if (linkedIntegration.isActive) {
            activeIntegrations[linkedIntegration.platform] = {
              isActive: true,
              linked: true,
              integrationId: linkedIntegration.integrationId,
              platformName: linkedIntegration.platformName,
              courseName: linkedIntegration.courseName,
              courseCode: linkedIntegration.courseCode,
              linkedAt: linkedIntegration.linkedAt
            };
            userIntegrationCount++;
          }
        });
      } else {
        // Fallback: Handle old format user-specific integrations
        const userIntegrations = course.integrations?.[userId] || {};
        
        // Filter and count active integrations for this user
        Object.entries(userIntegrations).forEach(([platform, integration]) => {
          if (integration && integration.isActive) {
            activeIntegrations[platform] = integration;
            userIntegrationCount++;
          }
        });
        
        // If this is an imported Gradescope course, treat it as having a Gradescope integration
        if (course.source === 'gradescope' && course.externalId) {
          activeIntegrations.gradescope = {
            isActive: true,
            imported: true,
            externalId: course.externalId,
            courses: [{ id: course.externalId, name: course.name }],
            assignments: course.assignments || [],
            materials: course.materials || []
          };
          userIntegrationCount++;
        }
      }
      
      return {
        id: course.id,
        name: course.name,
        subject: course.code || course.name,
        role: course.userRole,
        type: 'course',
        integrations: activeIntegrations,
        linkedIntegrations: course.linkedIntegrations || [], // Include linked integrations for UI
        totalIntegrations: userIntegrationCount,
        totalAssignments: course.analytics?.totalAssignments || course.assignments?.length || 0,
        totalMaterials: course.materials?.length || 0,
        semester: course.semester,
        year: course.year,
        instructor: course.instructor
      };
    });
    
    return {
      teaching: teachingClassrooms.map(c => ({
        id: c.id,
        name: c.name,
        subject: c.subject,
        role: 'teacher',
        type: 'classroom'
      })),
      enrolled: enrolledClassrooms.map(c => ({
        id: c.id,
        name: c.name,
        subject: c.subject,
        role: 'student',
        type: 'classroom'
      })),
      courses: courseClassrooms
    };
  } catch (error) {
    console.error('Error getting available classrooms:', error);
    return { teaching: [], enrolled: [], courses: [] };
  }
}

/**
 * Get integrated course materials for AI context
 * @param {string} userId - User ID
 * @param {string} contextId - Classroom or Course ID
 * @param {string} contextType - 'classroom' or 'course'
 * @returns {Promise<Array>} - Course materials from integrations
 */
async function getIntegratedMaterials(userId, contextId, contextType = 'classroom') {
  try {
    const Course = require('../models/course.model');
    
    let materials = [];
    let assignments = [];
    let announcements = [];
    
    if (contextType === 'course') {
      // Handle course context
      const course = await Course.getById(contextId);
      if (!course || !course.members.includes(userId)) {
        return { materials: [], assignments: [], announcements: [] };
      }
      
      console.log(`[AI Service] Processing course context for course: ${course.name}`);
      
      // NEW: Handle user-specific linked integrations (new merge functionality)
      if (course.userLinkedIntegrations && course.userLinkedIntegrations[userId] && course.userLinkedIntegrations[userId].length > 0) {
        console.log(`[AI Service] Found ${course.userLinkedIntegrations[userId].length} user-specific linked integrations`);
        
        // Get user-specific aggregated content from the course
        const userAggregatedData = course.userAggregatedData?.[userId];
        if (userAggregatedData) {
          materials = userAggregatedData.materials || [];
          assignments = userAggregatedData.assignments || [];
          announcements = userAggregatedData.announcements || [];
          
          console.log(`[AI Service] User-specific aggregated content: ${materials.length} materials, ${assignments.length} assignments, ${announcements.length} announcements`);
        } else {
          console.log(`[AI Service] No aggregated data found for user, triggering aggregation`);
          // Trigger aggregation for this user
          const Course = require('../models/course.model');
          await Course.aggregateUserLinkedIntegrationContent(contextId, userId);
          
          // Reload course data
          const updatedCourse = await Course.getById(contextId);
          const updatedUserData = updatedCourse.userAggregatedData?.[userId];
          if (updatedUserData) {
            materials = updatedUserData.materials || [];
            assignments = updatedUserData.assignments || [];
            announcements = updatedUserData.announcements || [];
          }
        }
      } 
      // Fallback: Check for legacy global linked integrations
      else if (course.linkedIntegrations && course.linkedIntegrations.length > 0) {
        console.log(`[AI Service] Found ${course.linkedIntegrations.length} legacy linked integrations`);
        
        // Get aggregated content from the course (legacy format)
        materials = course.materials || [];
        assignments = course.assignments || [];
        announcements = course.announcements || [];
        
        console.log(`[AI Service] Legacy aggregated content: ${materials.length} materials, ${assignments.length} assignments, ${announcements.length} announcements`);
      } else {
        // Fallback: Get materials and assignments from course aggregation (old format)
        materials = course.materials || [];
        assignments = course.assignments || [];
        announcements = course.announcements || [];
        
        // If this is an imported Gradescope course, add its data as materials
        if (course.source === 'gradescope' && course.externalId) {
          // Add course info as material
          materials.push({
            id: course.externalId,
            name: course.name,
            type: 'course_info',
            platform: 'gradescope',
            contextId,
            contextType: 'course',
            imported: true,
            content: `Course: ${course.name}${course.code ? ` (${course.code})` : ''}${course.instructor ? ` - Instructor: ${course.instructor}` : ''}`
          });
        }
        
        // Also get user-specific integration materials (old format)
        const userIntegrations = course.integrations?.[userId] || {};
        Object.entries(userIntegrations).forEach(([platform, integration]) => {
          if (integration && integration.isActive) {
            // Add materials from this integration
            if (integration.materials && Array.isArray(integration.materials)) {
              materials.push(...integration.materials.map(material => ({
                ...material,
                platform,
                contextId,
                contextType: 'course'
              })));
            }
            
            // Add assignments from this integration
            if (integration.assignments && Array.isArray(integration.assignments)) {
              assignments.push(...integration.assignments.map(assignment => ({
                ...assignment,
                platform,
                contextId,
                contextType: 'course'
              })));
            }
          }
        });
      }
      
    } else {
      // Handle classroom context (existing logic)
      const classroom = await Classroom.getById(contextId);
      if (!classroom || (!classroom.enrolledStudents.includes(userId) && classroom.teacherId !== userId)) {
        return { materials: [], assignments: [], announcements: [] };
      }
      
      const studentIntegrations = classroom.integrations[userId] || {};
      
      // Collect materials from all active integrations
      Object.entries(studentIntegrations).forEach(([platform, integration]) => {
        if (integration.isActive && integration.materials) {
          materials.push(...integration.materials.map(material => ({
            ...material,
            platform,
            contextId,
            contextType: 'classroom'
          })));
        }
        
        if (integration.isActive && integration.assignments) {
          assignments.push(...integration.assignments.map(assignment => ({
            ...assignment,
            platform,
            contextId,
            contextType: 'classroom'
          })));
        }
      });
    }
    
    console.log(`[AI Service] Final context summary: ${materials.length} materials, ${assignments.length} assignments, ${announcements.length} announcements`);
    
    return {
      materials,
      assignments,
      announcements,
      totalMaterials: materials.length,
      totalAssignments: assignments.length,
      totalAnnouncements: announcements.length
    };
  } catch (error) {
    console.error('Error getting integrated materials:', error);
    return { materials: [], assignments: [], announcements: [] };
  }
}

module.exports = {
  generateStudyPlan,
  answerQuestion,
  explainConcept,
  startChat,
  sendMessage,
  getChatHistory,
  getChatSessions,
  deleteChatSession,
  generateQuiz,
  submitQuiz,
  getQuizResults,
  getQuizzes,
  generateSummary,
  getAvailableClassrooms,
  getIntegratedMaterials
}; 