const { db } = require('../../config/firebase');
const NeuralConquestController = require('./neural-conquest.controller');

class SessionController {
  constructor() {
    this.neuralConquestController = new NeuralConquestController();
  }

  async startSession(req, res) {
    try {
      const { gameMode, courseId, settings = {} } = req.body;
      const userId = req.user.uid;

      console.log(`üéÆ Starting session for gameMode: ${gameMode}, userId: ${userId}, courseId: ${courseId}`);

      if (!gameMode) {
        console.error('‚ùå Game mode is required');
        return res.status(400).json({
          success: false,
          message: 'Game mode is required'
        });
      }

      // Enhanced: Handle Neural Conquest with custom topics
      if (gameMode === 'neural-conquest') {
        console.log('üß† Starting Neural Conquest game...');
        
        try {
          // Get user info for player name
          const userDoc = await db.collection('users').doc(userId).get();
          const userData = userDoc.exists ? userDoc.data() : {};
          const playerName = userData.displayName || userData.name || `Player_${userId.substr(0, 8)}`;
          
          console.log(`üë§ Player name: ${playerName}`);

          // Check if custom topics are provided
          let topic = 'General Knowledge';
          let customTopicData = null;
          
          if (settings.customTopics && Array.isArray(settings.customTopics)) {
            console.log('üé® Using custom generated topics:', settings.customTopics.length);
            topic = settings.topicDescription || 'Custom Topics';
            customTopicData = {
              topic: topic,
              isCustom: true,
              objects: settings.customTopics.map((customTopic, index) => ({
                id: customTopic.id || `custom_${index}`,
                name: customTopic.name,
                concept: customTopic.concept,
                description: customTopic.description,
                difficulty: customTopic.difficulty || 2,
                cost: customTopic.cost || 500,
                educationalValue: customTopic.educationalValue,
                icon: customTopic.icon || 'üéØ',
                
                // 3D Model properties from AI generation
                modelUrl: customTopic.modelUrl,
                textureUrl: customTopic.textureUrl,
                normalUrl: customTopic.normalUrl,
                roughnessUrl: customTopic.roughnessUrl,
                emissiveUrl: customTopic.emissiveUrl,
                thumbnailUrl: customTopic.thumbnailUrl,
                materials: customTopic.materials || ['standard'],
                quality: customTopic.quality || 'standard',
                isCustomGenerated: customTopic.isCustomGenerated || false,
                isFallback: customTopic.isFallback || false,
                modelPrompt: customTopic.modelPrompt,
                animations: customTopic.animations || ['float', 'glow'],
                interactionType: customTopic.interactionType || 'click_to_explore',
                position: customTopic.position || { x: 0, y: 0, z: 0 },
                
                // Enhanced metadata
                metadata: {
                  generatedAt: customTopic.metadata?.generatedAt || new Date().toISOString(),
                  concept: customTopic.concept,
                  shapEGenerated: customTopic.metadata?.shapEGenerated,
                  isEnhanced: true,
                  hasCustomModel: customTopic.isCustomGenerated && !customTopic.isFallback,
                  workflowStep: 'custom_topics_processed'
                }
              })),
              questions: [], // Will be generated by Neural Conquest controller
              isCustom: true,
              metadata: {
                originalTopicCount: settings.customTopics.length,
                processedAt: new Date().toISOString(),
                hasEnhanced3D: settings.customTopics.some(t => t.isCustomGenerated),
                customModelsCount: settings.customTopics.filter(t => t.isCustomGenerated).length,
                fallbackModelsCount: settings.customTopics.filter(t => t.isFallback).length
              }
            };
            
            console.log(`üéØ Custom topic data prepared:`, {
              objectCount: customTopicData.objects.length,
              hasEnhanced3D: customTopicData.metadata.hasEnhanced3D,
              customModels: customTopicData.metadata.customModelsCount,
              fallbackModels: customTopicData.metadata.fallbackModelsCount
            });
          }

          // Create proper request body for Neural Conquest controller
          const neuralReq = {
            ...req,
            body: {
              userId: userId,
              topic: topic,
              difficulty: settings.difficulty || 'medium',
              gameMode: 'single',
              playerName: playerName,
              customTopicData: customTopicData
            }
          };

          console.log('üöÄ Calling Neural Conquest controller with:', {
            userId: neuralReq.body.userId,
            topic: neuralReq.body.topic,
            difficulty: neuralReq.body.difficulty,
            hasCustomData: !!neuralReq.body.customTopicData,
            customObjectCount: neuralReq.body.customTopicData?.objects?.length || 0
          });

          // Call the specialized Neural Conquest controller
          return await this.neuralConquestController.startNewGame(neuralReq, res);
          
        } catch (neuralError) {
          console.error('‚ùå Error in Neural Conquest startup:', neuralError);
          console.error('Stack trace:', neuralError.stack);
          
          return res.status(500).json({
            success: false,
            message: 'Failed to start Neural Conquest game',
            error: neuralError.message,
            debug: process.env.NODE_ENV === 'development' ? {
              stack: neuralError.stack,
              details: neuralError.toString()
            } : undefined
          });
        }
      }

      // Handle other game modes
      console.log(`üé≤ Starting generic game session for mode: ${gameMode}`);
      
      const sessionId = `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

      const session = {
        sessionId,
        gameMode,
        courseId: courseId || 'general',
        userId,
        startedAt: new Date().toISOString(),
        status: 'active',
        progress: {
          currentLevel: 1,
          score: 0,
          streak: 0,
          completedChallenges: 0
        },
        settings: {
          anonymousMode: settings.anonymousMode || true,
          adaptiveDifficulty: settings.adaptiveDifficulty || true,
          detailedAnalytics: settings.detailedAnalytics || true
        }
      };

      await db.collection('game_sessions').doc(sessionId).set(session);

      console.log(`‚úÖ Generic game session created: ${sessionId}`);

      res.json({
        success: true,
        sessionId,
        data: session,
        message: 'Game session started successfully!'
      });

    } catch (error) {
      console.error('‚ùå Error in startSession:', error);
      console.error('Stack trace:', error.stack);
      console.error('Request body:', req.body);
      console.error('User ID:', req.user?.uid);
      
      res.status(500).json({
        success: false,
        message: 'Failed to start game session',
        error: error.message,
        debug: process.env.NODE_ENV === 'development' ? {
          stack: error.stack,
          requestBody: req.body,
          userId: req.user?.uid
        } : undefined
      });
    }
  }

  async joinActivity(req, res) {
    try {
      const { activityId } = req.params;
      const userId = req.user.uid;

      const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

      const session = {
        sessionId,
        activityId,
        userId,
        startedAt: new Date().toISOString(),
        status: 'active',
        progress: {
          score: 0,
          streak: 0,
          currentLevel: 1
        }
      };

      await db.collection('game_sessions').doc(sessionId).set(session);

      res.json({
        success: true,
        data: {
          sessionId,
          activityId,
          userId,
          joinedAt: new Date().toISOString()
        }
      });

    } catch (error) {
      console.error('Error joining activity:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to join activity'
      });
    }
  }

  async submitActivityResponse(req, res) {
    try {
      const { sessionId, response, timeSpent } = req.body;
      const userId = req.user.uid;

      const sessionRef = db.collection('game_sessions').doc(sessionId);
      const sessionDoc = await sessionRef.get();

      if (!sessionDoc.exists) {
        return res.status(404).json({
          success: false,
          message: 'Session not found'
        });
      }

      const sessionData = sessionDoc.data();
      if (sessionData.userId !== userId) {
        return res.status(403).json({
          success: false,
          message: 'Unauthorized'
        });
      }

      const updatedProgress = {
        ...sessionData.progress,
        lastResponse: response,
        lastResponseTime: new Date().toISOString(),
        totalTimeSpent: (sessionData.progress.totalTimeSpent || 0) + timeSpent
      };

      await sessionRef.update({
        progress: updatedProgress,
        updatedAt: new Date().toISOString()
      });

      res.json({
        success: true,
        message: 'Response submitted successfully'
      });

    } catch (error) {
      console.error('Error submitting response:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to submit response'
      });
    }
  }

  async getLeaderboard(req, res) {
    try {
      const { activityId } = req.params;
      const { limit = 10 } = req.query;

      const sessionsRef = db.collection('game_sessions')
        .where('activityId', '==', activityId)
        .orderBy('progress.score', 'desc')
        .limit(parseInt(limit));

      const sessionsSnapshot = await sessionsRef.get();
      const leaderboard = [];

      for (const doc of sessionsSnapshot.docs) {
        const sessionData = doc.data();
        
        const userRef = db.collection('users').doc(sessionData.userId);
        const userDoc = await userRef.get();
        const userData = userDoc.exists ? userDoc.data() : { displayName: 'Anonymous' };

        leaderboard.push({
          userId: sessionData.userId,
          displayName: userData.displayName,
          score: sessionData.progress.score,
          streak: sessionData.progress.streak,
          completedAt: sessionData.completedAt
        });
      }

      res.json({
        success: true,
        data: leaderboard
      });

    } catch (error) {
      console.error('Error getting leaderboard:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to get leaderboard'
      });
    }
  }
}

module.exports = SessionController;
