const GeminiService = require('../services/gemini.service');
const PDFService = require('../services/pdf.service');

class PracticeExamController {
  /**
   * Generate practice exam using EXACT working standalone scripts (with PDF) or GeminiService (without PDF)
   */
  static async generatePracticeExam(req, res) {
    console.log('=== PRACTICE EXAM GENERATION ===');
    console.log('Body:', req.body);
    console.log('File:', req.file);

    try {
      const { subject, numQuestions, difficulty, generatePDF, instructions, questionPoints } = req.body;

      // Parse question points
      let parsedQuestionPoints;
      try {
        parsedQuestionPoints = JSON.parse(questionPoints || '[]');
        console.log('Parsed question points:', parsedQuestionPoints);
      } catch (error) {
        console.log('Error parsing question points, using defaults');
        const count = parseInt(numQuestions) || 10;
        parsedQuestionPoints = Array(count).fill(Math.round(100 / count));
      }

      // CASE 1: PDF uploaded - use standalone scripts
      if (req.file) {
        console.log('=== USING STANDALONE SCRIPTS (WITH PDF) ===');
        return await PracticeExamController.generatePracticeExamWithPDF(req, res, parsedQuestionPoints);
      }
      // CASE 2: No PDF - use GeminiService for general questions
      else {
        console.log('=== USING GEMINI SERVICE (NO PDF) ===');
        return await PracticeExamController.generatePracticeExamWithoutPDF(req, res, parsedQuestionPoints);
      }
    } catch (error) {
      console.error('‚ùå Practice exam generation failed:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to generate practice exam',
        details: error.message
      });
    }
  }

  /**
   * Generate practice exam WITH PDF using standalone scripts
   */
  static async generatePracticeExamWithPDF(req, res, parsedQuestionPoints) {
    const { subject, numQuestions, difficulty, instructions } = req.body;

    console.log(`üéØ Generating ${numQuestions} questions from PDF, difficulty: ${difficulty}`);
    console.log('üöÄ CALLING EXACT WORKING STANDALONE SCRIPTS');
    console.log(`üìÑ req.file.path: ${req.file.path}`);
    console.log(`üìÑ req.file.filename: ${req.file.filename}`);
    console.log(`üìÑ req.file.destination: ${req.file.destination}`);

    const { execSync } = require('child_process');
    const fs = require('fs');
    const path = require('path');

    const projectRoot = path.join(__dirname, '../../');
    const backendDir = path.join(__dirname, '../');

    let pdfPath;
    if (path.isAbsolute(req.file.path)) {
      pdfPath = req.file.path;
    } else {
      pdfPath = path.join(backendDir, req.file.path);
    }

    if (!fs.existsSync(pdfPath)) {
      const alternativePaths = [
        path.join(projectRoot, req.file.path),
        path.join(projectRoot, 'backend', req.file.path),
        path.join(backendDir, 'uploads', req.file.filename),
        path.join(projectRoot, 'backend', 'uploads', req.file.filename)
      ];
      for (const altPath of alternativePaths) {
        if (fs.existsSync(altPath)) {
          pdfPath = altPath;
          break;
        }
      }
      if (!fs.existsSync(pdfPath)) {
        throw new Error(`PDF file not found. Last tried: ${pdfPath}`);
      }
    }

    console.log(`‚úÖ PDF found: ${pdfPath}`);

    // Step 1: Execute step1-pdf-extraction.js
    const step1Command = `cd "${projectRoot}" && node step1-pdf-extraction.js "${pdfPath}"`;
    execSync(step1Command, { encoding: 'utf8', timeout: 60000, cwd: projectRoot });

    // Step 2: Execute simple-gemini-conversion.js
    const step2Command = `cd "${projectRoot}" && node simple-gemini-conversion.js "${pdfPath}"`;
    execSync(step2Command, { encoding: 'utf8', timeout: 60000, cwd: projectRoot });

    // Step 2.5: Execute step2.5-simple.js with ALL user parameters
    const step25Subject = subject || '';
    const step25Instructions = instructions || '';
    const step25Command = `cd "${projectRoot}" && node step2.5-simple.js "${pdfPath}" ${numQuestions} ${difficulty} "${step25Subject}" "${step25Instructions}"`;
    execSync(step25Command, { encoding: 'utf8', timeout: 120000, cwd: projectRoot });

    // Find and copy the generated PDF
    const step25OutputDir = path.join(projectRoot, 'step2.5-output');
    const step25PdfFiles = fs.readdirSync(step25OutputDir).filter(f => f.endsWith('.pdf') && f.includes('simple-exam'));
    if (step25PdfFiles.length === 0) throw new Error('No PDF generated by step 2.5 script');

    const latestPdf = step25PdfFiles
      .map(filename => ({ filename, timestamp: (filename.match(/simple-exam-(\d+)\.pdf/) ? parseInt(filename.match(/simple-exam-(\d+)\.pdf/)[1]) : 0) }))
      .sort((a, b) => b.timestamp - a.timestamp)[0].filename;

    const sourcePdfPath = path.join(step25OutputDir, latestPdf);
    const uploadsDir = path.join(__dirname, '../uploads');
    if (!fs.existsSync(uploadsDir)) fs.mkdirSync(uploadsDir, { recursive: true });
    const destinationPdfPath = path.join(uploadsDir, latestPdf);
    fs.copyFileSync(sourcePdfPath, destinationPdfPath);
    const relativePdfPath = `backend/uploads/${latestPdf}`;

    // Extract questions for API response (read from generated LaTeX)
    const latexFile = path.join(step25OutputDir, latestPdf.replace('.pdf', '.tex'));
    let questions = 'Generated questions with visual elements';
    let parsedQuestions = [];
    if (fs.existsSync(latexFile)) {
      try {
        const latexContent = fs.readFileSync(latexFile, 'utf8');
        const extractedQuestions = PracticeExamController.extractQuestionsFromLatex(latexContent);
        if (extractedQuestions.length > 0) {
          questions = extractedQuestions.map(q => q.text).join('\n\n');
          const pdfQuestions = PracticeExamController.distributePointsUniversally(extractedQuestions, parsedQuestionPoints, parseInt(numQuestions));
          const interactiveQuestions = PracticeExamController.distributePointsForInteractive(extractedQuestions, parsedQuestionPoints);
          parsedQuestions = pdfQuestions;
          const responseData = {
            questions: questions,
            parsedQuestions: parsedQuestions,
            interactiveQuestions: interactiveQuestions,
            questionPoints: parsedQuestionPoints,
            subject: subject,
            difficulty: difficulty,
            pdfPath: relativePdfPath
          };
          return res.json({ success: true, data: responseData });
        } else {
          questions = `Generated ${numQuestions} practice exam questions with tables, diagrams, and code snippets`;
          parsedQuestions = Array.from({length: parseInt(numQuestions) || 5}, (_, index) => ({ id: index + 1, question: `Practice Question ${index + 1}: Complex problem with multiple parts`, points: parsedQuestionPoints[index] || Math.round(100 / (parseInt(numQuestions) || 5)) }));
        }
      } catch (error) {
        console.error('‚ùå Error reading LaTeX file:', error);
        questions = `Generated ${numQuestions} questions with TikZ diagrams, tables, and code snippets from working standalone scripts`;
        parsedQuestions = Array.from({length: parseInt(numQuestions) || 5}, (_, index) => ({ id: index + 1, question: `Generated Question ${index + 1}`, points: parsedQuestionPoints[index] || Math.round(100 / (parseInt(numQuestions) || 5)) }));
      }
    }

    const responseData = {
      questions: questions,
      parsedQuestions: parsedQuestions,
      questionPoints: parsedQuestionPoints,
      subject: subject,
      difficulty: difficulty,
      pdfPath: relativePdfPath
    };

    return res.json({ success: true, data: responseData });
  }

  /**
   * Generate practice exam WITHOUT PDF using GeminiService
   */
  static async generatePracticeExamWithoutPDF(req, res, parsedQuestionPoints) {
    const { subject, numQuestions, difficulty, generatePDF, instructions } = req.body;
    console.log(`üéØ Generating ${numQuestions} questions about ${subject}, difficulty: ${difficulty}`);

    const result = await GeminiService.generatePracticeExam({
      subject: subject,
      numQuestions: parseInt(numQuestions) || 10,
      difficulty: difficulty || 'medium',
      instructions: instructions || '',
      pdfPath: null
    });

    let pdfPath = null;
    if (generatePDF && result.text) {
      try {
        const pdfBuffer = await PDFService.generateExamPDF(result.text, subject, { difficulty: difficulty, questionPoints: parsedQuestionPoints });
        const fs = require('fs');
        const path = require('path');
        const uploadsDir = path.join(__dirname, '../uploads');
        if (!fs.existsSync(uploadsDir)) fs.mkdirSync(uploadsDir, { recursive: true });
        const timestamp = Date.now();
        const filename = `general-exam-${subject.replace(/\s+/g, '-')}-${timestamp}.pdf`;
        const fullPath = path.join(uploadsDir, filename);
        fs.writeFileSync(fullPath, pdfBuffer);
        pdfPath = `backend/uploads/${filename}`;
      } catch (pdfError) {
        console.error('‚ùå PDF generation failed:', pdfError);
      }
    }

    const responseData = {
      questions: result.text,
      questionPoints: parsedQuestionPoints,
      subject: subject,
      difficulty: difficulty,
      pdfPath: pdfPath
    };

    return res.json({ success: true, data: responseData });
  }

  // ================= Helpers copied from original AIController (practice exam specific) =================

  static extractQuestionsFromLatex(latexContent) {
    // We will require and reuse the exact helper methods from the original controller file to avoid duplication
    const AIController = require('./ai.controller');
    if (typeof AIController.extractQuestionsFromLatex === 'function') {
      return AIController.extractQuestionsFromLatex(latexContent);
    }
    return [];
  }

  static distributePointsUniversally(extractedQuestions, frontendPointDistribution, requestedNumQuestions) {
    const AIController = require('./ai.controller');
    if (typeof AIController.distributePointsUniversally === 'function') {
      return AIController.distributePointsUniversally(extractedQuestions, frontendPointDistribution, requestedNumQuestions);
    }
    return [];
  }

  static distributePointsForInteractive(extractedQuestions, frontendPointDistribution) {
    const AIController = require('./ai.controller');
    if (typeof AIController.distributePointsForInteractive === 'function') {
      return AIController.distributePointsForInteractive(extractedQuestions, frontendPointDistribution);
    }
    return [];
  }
}

module.exports = PracticeExamController;


