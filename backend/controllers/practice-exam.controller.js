const GeminiService = require('../services/gemini.service');
const PDFService = require('../services/pdf.service');

class PracticeExamController {
  /**
   * Generate practice exam using EXACT working standalone scripts (with PDF) or GeminiService (without PDF)
   */
  static async generatePracticeExam(req, res) {
    console.log('=== PRACTICE EXAM GENERATION ===');
    console.log('Body:', req.body);
    console.log('File:', req.file);

    try {
      const { subject, numQuestions, difficulty, generatePDF, instructions, questionPoints } = req.body;

      // Parse question points
      let parsedQuestionPoints;
      try {
        parsedQuestionPoints = JSON.parse(questionPoints || '[]');
        console.log('Parsed question points:', parsedQuestionPoints);
      } catch (error) {
        console.log('Error parsing question points, using defaults');
        const count = parseInt(numQuestions) || 10;
        parsedQuestionPoints = Array(count).fill(Math.round(100 / count));
      }

      // CASE 1: PDF uploaded - use standalone scripts
      if (req.file) {
        console.log('=== USING STANDALONE SCRIPTS (WITH PDF) ===');
        return await PracticeExamController.generatePracticeExamWithPDF(req, res, parsedQuestionPoints);
      }
      // CASE 2: No PDF - use GeminiService for general questions
      else {
        console.log('=== USING GEMINI SERVICE (NO PDF) ===');
        return await PracticeExamController.generatePracticeExamWithoutPDF(req, res, parsedQuestionPoints);
      }
    } catch (error) {
      console.error('‚ùå Practice exam generation failed:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to generate practice exam',
        details: error.message
      });
    }
  }

  /**
   * Generate practice exam WITH PDF using standalone scripts
   */
  static async generatePracticeExamWithPDF(req, res, parsedQuestionPoints) {
    const { subject, numQuestions, difficulty, instructions } = req.body;

    console.log(`üéØ Generating ${numQuestions} questions from PDF, difficulty: ${difficulty}`);
    console.log('üöÄ CALLING EXACT WORKING STANDALONE SCRIPTS');
    console.log(`üìÑ req.file.path: ${req.file.path}`);
    console.log(`üìÑ req.file.filename: ${req.file.filename}`);
    console.log(`üìÑ req.file.destination: ${req.file.destination}`);

    const { execSync } = require('child_process');
    const fs = require('fs');
    const path = require('path');

    const projectRoot = path.join(__dirname, '../../');
    const backendDir = path.join(__dirname, '../');

    let pdfPath;
    if (path.isAbsolute(req.file.path)) {
      pdfPath = req.file.path;
    } else {
      pdfPath = path.join(backendDir, req.file.path);
    }

    if (!fs.existsSync(pdfPath)) {
      const alternativePaths = [
        path.join(projectRoot, req.file.path),
        path.join(projectRoot, 'backend', req.file.path),
        path.join(backendDir, 'uploads', req.file.filename),
        path.join(projectRoot, 'backend', 'uploads', req.file.filename)
      ];
      for (const altPath of alternativePaths) {
        if (fs.existsSync(altPath)) {
          pdfPath = altPath;
          break;
        }
      }
      if (!fs.existsSync(pdfPath)) {
        throw new Error(`PDF file not found. Last tried: ${pdfPath}`);
      }
    }

    console.log(`‚úÖ PDF found: ${pdfPath}`);

    // Step 1: Execute step1-pdf-extraction.js
    const step1Command = `cd "${projectRoot}" && node step1-pdf-extraction.js "${pdfPath}"`;
    execSync(step1Command, { encoding: 'utf8', timeout: 60000, cwd: projectRoot });

    // Step 2: Execute simple-gemini-conversion.js
    const step2Command = `cd "${projectRoot}" && node simple-gemini-conversion.js "${pdfPath}"`;
    execSync(step2Command, { encoding: 'utf8', timeout: 60000, cwd: projectRoot });

    // Step 2.5: Execute step2.5-simple.js with ALL user parameters
    const step25Subject = subject || '';
    const step25Instructions = instructions || '';
    const step25Command = `cd "${projectRoot}" && node step2.5-simple.js "${pdfPath}" ${numQuestions} ${difficulty} "${step25Subject}" "${step25Instructions}"`;
    execSync(step25Command, { encoding: 'utf8', timeout: 120000, cwd: projectRoot });

    // Find and copy the generated PDF
    const step25OutputDir = path.join(projectRoot, 'step2.5-output');
    const step25PdfFiles = fs.readdirSync(step25OutputDir).filter(f => f.endsWith('.pdf') && f.includes('simple-exam'));
    if (step25PdfFiles.length === 0) throw new Error('No PDF generated by step 2.5 script');

    const latestPdf = step25PdfFiles
      .map(filename => ({ filename, timestamp: (filename.match(/simple-exam-(\d+)\.pdf/) ? parseInt(filename.match(/simple-exam-(\d+)\.pdf/)[1]) : 0) }))
      .sort((a, b) => b.timestamp - a.timestamp)[0].filename;

    const sourcePdfPath = path.join(step25OutputDir, latestPdf);
    const uploadsDir = path.join(__dirname, '../uploads');
    if (!fs.existsSync(uploadsDir)) fs.mkdirSync(uploadsDir, { recursive: true });
    const destinationPdfPath = path.join(uploadsDir, latestPdf);
    fs.copyFileSync(sourcePdfPath, destinationPdfPath);
    const relativePdfPath = `backend/uploads/${latestPdf}`;

    // Extract questions for API response (read from generated LaTeX)
    const latexFile = path.join(step25OutputDir, latestPdf.replace('.pdf', '.tex'));
    let questions = 'Generated questions with visual elements';
    let parsedQuestions = [];
    if (fs.existsSync(latexFile)) {
      try {
        const latexContent = fs.readFileSync(latexFile, 'utf8');
        console.log('üìÑ LaTeX content length:', latexContent.length);
        console.log('üìÑ LaTeX preview:', latexContent.substring(0, 500));
        
        const AIController = require('./ai.controller');
        let extractedQuestions = AIController.extractQuestionsFromLatex(latexContent);
        console.log('üîç Initial extraction found:', extractedQuestions.length, 'questions');
        console.log('üìã EXTRACTION DEBUG: Direct call to AIController.extractQuestionsFromLatex()');
        
        // ENHANCED: If extraction fails, try alternative patterns specifically for OS homework
        if (extractedQuestions.length === 0) {
          console.log('‚ö†Ô∏è Initial extraction failed, trying alternative patterns...');
          console.log('üìã EXTRACTION DEBUG: Entering fallback method: extractQuestionsWithFallback()');
          extractedQuestions = PracticeExamController.extractQuestionsWithFallback(latexContent);
          console.log('üîç Fallback extraction found:', extractedQuestions.length, 'questions');
          console.log('üìã EXTRACTION DEBUG: Fallback method completed');
        } else {
          console.log('üìã EXTRACTION DEBUG: Initial extraction succeeded, no fallback needed');
        }
        
        if (extractedQuestions.length > 0) {
          console.log('üìã RESPONSE DEBUG: ‚úÖ Questions extracted successfully, building response...');
          questions = extractedQuestions.map(q => q.text).join('\n\n');
          const pdfQuestions = PracticeExamController.distributePointsUniversally(extractedQuestions, parsedQuestionPoints, parseInt(numQuestions));
          const interactiveQuestions = PracticeExamController.distributePointsForInteractive(extractedQuestions, parsedQuestionPoints);
          parsedQuestions = pdfQuestions;
          
          console.log('üìã RESPONSE DEBUG: Created pdfQuestions:', pdfQuestions.length, 'items');
          console.log('üìã RESPONSE DEBUG: Created interactiveQuestions:', interactiveQuestions.length, 'items');
          console.log('üìã RESPONSE DEBUG: Questions text length:', questions.length, 'chars');
          
          // üóùÔ∏è GENERATE ANSWER KEY
          let answerKeyData = null;
          try {
            console.log('=== GENERATING ANSWER KEY FOR PDF EXAM ===');
            answerKeyData = await GeminiService.generateAnswerKey(questions, subject, {
              includeExplanations: true,
              includePartialCredit: true,
              includeRubrics: false,
              difficulty: difficulty
            });
            console.log('‚úÖ Answer key generated successfully');
          } catch (error) {
            console.error('‚ùå Answer key generation failed:', error);
            // Don't fail the entire request if answer key fails
          }

          const responseData = {
            questions: questions,
            parsedQuestions: parsedQuestions,
            interactiveQuestions: interactiveQuestions,
            questionPoints: parsedQuestionPoints,
            subject: subject,
            difficulty: difficulty,
            pdfPath: relativePdfPath,
            answerKey: answerKeyData // üóùÔ∏è Add answer key to response
          };
          
          console.log('üìã RESPONSE DEBUG: ===== FINAL RESPONSE SUMMARY =====');
          console.log('üìã RESPONSE DEBUG: Response will contain:');
          console.log('üìã RESPONSE DEBUG: - questions (text):', typeof responseData.questions, responseData.questions.length, 'chars');
          console.log('üìã RESPONSE DEBUG: - parsedQuestions (array):', Array.isArray(responseData.parsedQuestions), responseData.parsedQuestions.length, 'items');
          console.log('üìã RESPONSE DEBUG: - interactiveQuestions (array):', Array.isArray(responseData.interactiveQuestions), responseData.interactiveQuestions.length, 'items');
          console.log('üìã RESPONSE DEBUG: - questionPoints (array):', Array.isArray(responseData.questionPoints), responseData.questionPoints.length, 'items');
          console.log('üìã RESPONSE DEBUG: - pdfPath:', responseData.pdfPath);
          console.log('üìã RESPONSE DEBUG: - answerKey:', responseData.answerKey ? 'present' : 'null');
          console.log('üìã RESPONSE DEBUG: ‚úÖ SUCCESS - Frontend will receive interactiveQuestions');
          console.log('üìã RESPONSE DEBUG: ==========================================');
          
          return res.json({ success: true, data: responseData });
        } else {
          console.log('üìã RESPONSE DEBUG: ‚ùå NO QUESTIONS EXTRACTED - Creating fallback response');
          console.log('üìã RESPONSE DEBUG: This will result in generic placeholder questions');
          console.log('üìã RESPONSE DEBUG: Frontend will likely fall back to weak parsing');
          questions = `Generated ${numQuestions} practice exam questions with tables, diagrams, and code snippets`;
          parsedQuestions = Array.from({length: parseInt(numQuestions) || 5}, (_, index) => ({ id: index + 1, question: `Practice Question ${index + 1}: Complex problem with multiple parts`, points: parsedQuestionPoints[index] || Math.round(100 / (parseInt(numQuestions) || 5)) }));
          
          console.log('üìã RESPONSE DEBUG: ===== FAILURE RESPONSE SUMMARY =====');
          console.log('üìã RESPONSE DEBUG: - interactiveQuestions: NOT CREATED (null/undefined)');
          console.log('üìã RESPONSE DEBUG: - parsedQuestions: generic placeholders');
          console.log('üìã RESPONSE DEBUG: - questions: generic text');
          console.log('üìã RESPONSE DEBUG: ‚ùå FAILURE - Frontend will use weak parsing');
          console.log('üìã RESPONSE DEBUG: ==========================================');
        }
      } catch (error) {
        console.error('‚ùå Error reading LaTeX file:', error);
        questions = `Generated ${numQuestions} questions with TikZ diagrams, tables, and code snippets from working standalone scripts`;
        parsedQuestions = Array.from({length: parseInt(numQuestions) || 5}, (_, index) => ({ id: index + 1, question: `Generated Question ${index + 1}`, points: parsedQuestionPoints[index] || Math.round(100 / (parseInt(numQuestions) || 5)) }));
      }
    }

    const responseData = {
      questions: questions,
      parsedQuestions: parsedQuestions,
      questionPoints: parsedQuestionPoints,
      subject: subject,
      difficulty: difficulty,
      pdfPath: relativePdfPath
    };

    return res.json({ success: true, data: responseData });
  }

  /**
   * Generate practice exam WITHOUT PDF using GeminiService
   */
  static async generatePracticeExamWithoutPDF(req, res, parsedQuestionPoints) {
    const { subject, numQuestions, difficulty, generatePDF, instructions } = req.body;
    console.log(`üéØ Generating ${numQuestions} questions about ${subject}, difficulty: ${difficulty}`);

    const result = await GeminiService.generatePracticeExam({
      subject: subject,
      numQuestions: parseInt(numQuestions) || 10,
      difficulty: difficulty || 'medium',
      instructions: instructions || '',
      pdfPath: null
    });

    // üóùÔ∏è GENERATE ANSWER KEY FOR NON-PDF EXAM
    let answerKeyData = null;
    try {
      console.log('=== GENERATING ANSWER KEY FOR NON-PDF EXAM ===');
      console.log('üìù Questions text length:', result.text?.length || 0);
      console.log('üìù Questions preview:', result.text?.substring(0, 200) || 'No text');
      
      answerKeyData = await GeminiService.generateAnswerKey(result.text, subject, {
        includeExplanations: true,
        includePartialCredit: true,
        includeRubrics: false,
        difficulty: difficulty || 'medium'
      });
      console.log('‚úÖ Answer key generated successfully');
      console.log('üóùÔ∏è Answer key data:', !!answerKeyData);
      console.log('üóùÔ∏è Answer key text length:', answerKeyData?.answerKey?.length || 0);
    } catch (error) {
      console.error('‚ùå Answer key generation failed:', error);
      console.error('Error details:', error.message);
      console.error('Error stack:', error.stack);
      // Don't fail the entire request if answer key fails
    }

    let pdfPath = null;
    if (generatePDF && result.text) {
      try {
        const pdfBuffer = await PDFService.generateExamPDF(result.text, subject, { difficulty: difficulty, questionPoints: parsedQuestionPoints });
        const fs = require('fs');
        const path = require('path');
        const uploadsDir = path.join(__dirname, '../uploads');
        if (!fs.existsSync(uploadsDir)) fs.mkdirSync(uploadsDir, { recursive: true });
        const timestamp = Date.now();
        const filename = `general-exam-${subject.replace(/\s+/g, '-')}-${timestamp}.pdf`;
        const fullPath = path.join(uploadsDir, filename);
        fs.writeFileSync(fullPath, pdfBuffer);
        pdfPath = `backend/uploads/${filename}`;
      } catch (pdfError) {
        console.error('‚ùå PDF generation failed:', pdfError);
      }
    }

    const responseData = {
      questions: result.text,
      questionPoints: parsedQuestionPoints,
      subject: subject,
      difficulty: difficulty,
      pdfPath: pdfPath,
      answerKey: answerKeyData // üóùÔ∏è Add answer key to response
    };

    return res.json({ success: true, data: responseData });
  }

  // ================= Helpers copied from original AIController (practice exam specific) =================



  static distributePointsUniversally(extractedQuestions, frontendPointDistribution, requestedNumQuestions) {
    const AIController = require('./ai.controller');
    if (typeof AIController.distributePointsUniversally === 'function') {
      return AIController.distributePointsUniversally(extractedQuestions, frontendPointDistribution, requestedNumQuestions);
    }
    return [];
  }

  static distributePointsForInteractive(extractedQuestions, frontendPointDistribution) {
    const AIController = require('./ai.controller');
    if (typeof AIController.distributePointsForInteractive === 'function') {
      return AIController.distributePointsForInteractive(extractedQuestions, frontendPointDistribution);
    }
    return [];
  }

  /**
   * Enhanced fallback extraction for difficult PDFs like OS_hw4
   */
  static extractQuestionsWithFallback(latexContent) {
    console.log('üîß FALLBACK: Enhanced question extraction...');
    console.log('üìã FALLBACK DEBUG: Starting 3-tier fallback extraction system');
    const questions = [];
    
    try {
      // Method 1: Look for Problem sections with different patterns
      console.log('üìã FALLBACK DEBUG: Trying Method 1 - Problem/Question section patterns');
      const problemPatterns = [
        /\\section\*?\{Problem\s+(\d+)[^}]*\}([\s\S]*?)(?=\\section\*?\{Problem\s+\d+|\\end\{document\}|$)/gi,
        /\\section\*?\{Question\s+(\d+)[^}]*\}([\s\S]*?)(?=\\section\*?\{Question\s+\d+|\\end\{document\}|$)/gi,
        /\\section\*?\{(\d+)\.[^}]*\}([\s\S]*?)(?=\\section\*?\{\d+\.|\\end\{document\}|$)/gi
      ];
      
      for (let patternIndex = 0; patternIndex < problemPatterns.length; patternIndex++) {
        const pattern = problemPatterns[patternIndex];
        const matches = [...latexContent.matchAll(pattern)];
        console.log(`üìã FALLBACK DEBUG: Pattern ${patternIndex + 1} (${pattern.toString()}) found ${matches.length} matches`);
        
        matches.forEach((match, index) => {
          const questionNum = match[1];
          const content = match[2];
          
          // Clean the content
          const cleanContent = content
            .replace(/\\begin\{[^}]+\}[\s\S]*?\\end\{[^}]+\}/g, '') // Remove environments
            .replace(/\\[a-zA-Z]+\*?\{[^}]*\}/g, '') // Remove commands
            .replace(/\\[a-zA-Z]+\*/g, '') // Remove commands without args
            .replace(/\s+/g, ' ')
            .trim();
          
          if (cleanContent.length > 50) {
            questions.push({
              text: `Q${questionNum}) ${cleanContent}`,
              points: 10 // Default points
            });
            console.log(`‚úÖ FALLBACK DEBUG: Method 1 extracted Question ${questionNum}: ${cleanContent.substring(0, 80)}...`);
          }
        });
        
        if (questions.length > 0) {
          console.log(`üìã FALLBACK DEBUG: Method 1 succeeded with pattern ${patternIndex + 1}, found ${questions.length} questions`);
          break; // Stop if we found questions
        }
      }
      
      if (questions.length === 0) {
        console.log('üìã FALLBACK DEBUG: Method 1 failed, no section patterns matched');
      }
      
      // Method 2: If still no questions, look for enumerate items
      if (questions.length === 0) {
        console.log('üìã FALLBACK DEBUG: Trying Method 2 - Enumerate item extraction');
        const itemMatches = latexContent.match(/\\item\s+([^\\]*(?:\\[^i][^t][^e][^m][^\\]*)*)/g);
        console.log(`üìã FALLBACK DEBUG: Method 2 found ${itemMatches ? itemMatches.length : 0} \\item matches`);
        
        if (itemMatches) {
          itemMatches.forEach((item, index) => {
            const cleanItem = item
              .replace(/\\item\s+/, '')
              .replace(/\\[a-zA-Z]+\*?\{[^}]*\}/g, '')
              .replace(/\\[a-zA-Z]+\*/g, '')
              .replace(/\s+/g, ' ')
              .trim();
            
            if (cleanItem.length > 30 && !cleanItem.toLowerCase().includes('honor code')) {
              questions.push({
                text: `Q${index + 1}) ${cleanItem}`,
                points: 10
              });
              console.log(`‚úÖ FALLBACK DEBUG: Method 2 extracted Item ${index + 1}: ${cleanItem.substring(0, 80)}...`);
            } else {
              console.log(`üìã FALLBACK DEBUG: Method 2 skipped item ${index + 1} (too short or honor code): ${cleanItem.substring(0, 50)}...`);
            }
          });
          console.log(`üìã FALLBACK DEBUG: Method 2 completed, extracted ${questions.length} questions from items`);
        } else {
          console.log('üìã FALLBACK DEBUG: Method 2 failed, no \\item patterns found');
        }
      }
      
      // Method 3: Last resort - split by meaningful patterns
      if (questions.length === 0) {
        console.log('üìã FALLBACK DEBUG: Trying Method 3 - Heuristic line-by-line splitting');
        const lines = latexContent.split('\n');
        console.log(`üìã FALLBACK DEBUG: Method 3 processing ${lines.length} lines`);
        let currentQuestion = '';
        let questionCount = 0;
        let questionIndicatorsFound = 0;
        
        for (const line of lines) {
          const trimmed = line.trim();
          
          // Skip LaTeX commands and short lines
          if (trimmed.startsWith('\\') || trimmed.length < 10) continue;
          
          // Look for question indicators
          if (trimmed.match(/^\d+\./) || 
              trimmed.match(/^[a-z]\)/) || 
              trimmed.match(/question|problem|what|how|why|explain|describe|calculate|find|solve|consider/i)) {
            
            questionIndicatorsFound++;
            console.log(`üìã FALLBACK DEBUG: Method 3 found question indicator ${questionIndicatorsFound}: ${trimmed.substring(0, 60)}...`);
            
            // Save previous question
            if (currentQuestion.trim().length > 50) {
              questionCount++;
              questions.push({
                text: `Q${questionCount}) ${currentQuestion.trim()}`,
                points: 10
              });
              console.log(`‚úÖ FALLBACK DEBUG: Method 3 extracted Heuristic ${questionCount}: ${currentQuestion.substring(0, 80)}...`);
            }
            
            currentQuestion = trimmed;
          } else if (currentQuestion && trimmed.length > 0) {
            currentQuestion += ' ' + trimmed;
          }
        }
        
        // Don't forget the last question
        if (currentQuestion.trim().length > 50) {
          questionCount++;
          questions.push({
            text: `Q${questionCount}) ${currentQuestion.trim()}`,
            points: 10
          });
          console.log(`‚úÖ FALLBACK DEBUG: Method 3 extracted final question ${questionCount}: ${currentQuestion.substring(0, 80)}...`);
        }
        
        console.log(`üìã FALLBACK DEBUG: Method 3 completed, found ${questionIndicatorsFound} indicators, extracted ${questions.length} questions`);
      }
      
    } catch (error) {
      console.error('‚ùå FALLBACK DEBUG: Fallback extraction failed:', error);
      console.log('üìã FALLBACK DEBUG: Exception occurred, returning empty questions array');
    }
    
    console.log(`üìã FALLBACK DEBUG: ===== FALLBACK EXTRACTION SUMMARY =====`);
    console.log(`üìã FALLBACK DEBUG: Final result: ${questions.length} questions extracted`);
    if (questions.length > 0) {
      console.log(`üìã FALLBACK DEBUG: Successfully used fallback extraction methods`);
      questions.forEach((q, i) => {
        console.log(`üìã FALLBACK DEBUG: Question ${i+1}: ${q.text.substring(0, 60)}...`);
      });
    } else {
      console.log(`üìã FALLBACK DEBUG: ‚ö†Ô∏è ALL FALLBACK METHODS FAILED - No questions extracted`);
    }
    console.log(`üìã FALLBACK DEBUG: ==========================================`);
    
    return questions;
  }
}

module.exports = PracticeExamController;


